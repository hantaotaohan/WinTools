{"ns_map":["http://www.w3.org/1999/xhtml"],"tree":[0,[1,[387],[388],[389],[390]],[2,[3,[4,[381,[382,[383,[384],[385],[386]]]]],[5],[6],[7,[376],[377],[378],[379],[380]],[8,[161],[162,[375]],[163],[164,[359,[360,[361],[362],[363],[364],[365],[366],[367],[368],[369],[370],[371],[372],[373],[374]]]],[165,[354],[355],[356],[357],[358]],[166,[347],[348],[349],[350],[351],[352],[353]],[167,[346]],[168],[169,[335,[336,[344,[345]]],[337,[343]],[338,[341,[342]]],[339,[340]]]],[170,[334]],[171,[321,[322,[323],[324],[325],[326],[327],[328],[329],[330],[331],[332],[333]]]],[172,[319],[320]],[173,[290,[291,[292],[293],[294],[295],[296],[297],[298],[299],[300],[301],[302],[303],[304],[305],[306],[307],[308],[309],[310],[311],[312],[313],[314],[315],[316],[317],[318]]]],[174,[271,[272,[289]],[273,[287],[288]],[274,[286]],[275,[285]],[276,[284]],[277,[283]],[278,[282]],[279,[280],[281]]]],[175,[270]],[176,[220],[221],[222,[269]],[223,[259,[260,[261],[262],[263],[264],[265],[266],[267],[268]]]],[224,[258]],[225,[249,[250,[257]],[251,[256]],[252,[255]],[253,[254]]]],[226,[247],[248]],[227,[234,[235,[236],[237],[238],[239],[240],[241],[242],[243],[244],[245],[246]]]],[228,[232],[233]],[229,[230],[231]]],[177,[183],[184,[219]],[185,[209],[210,[218]],[211,[213,[214,[215],[216],[217]]]],[212]],[186,[200],[201,[208]],[202,[204,[205,[206],[207]]]],[203]],[187,[188],[189,[199]],[190,[191,[192,[193],[194],[195],[196],[197],[198]]]]]],[178,[179],[180,[181],[182]]]],[9,[10],[11,[160]],[12,[136],[137,[159]],[138,[148,[149,[150],[151],[152],[153],[154],[155],[156],[157],[158]]]],[139,[146],[147]],[140,[145]],[141,[142,[143,[144]]]]],[13,[66],[67],[68,[134],[135]],[69,[124,[125,[126],[127],[128],[129],[130],[131],[132],[133]]]],[70,[121],[122],[123]],[71,[120]],[72,[102,[103,[104],[105],[106],[107],[108],[109],[110],[111],[112],[113],[114],[115],[116],[117],[118],[119]]]],[73],[74,[96],[97],[98],[99],[100],[101]],[75,[93],[94],[95]],[76,[89],[90],[91],[92]],[77,[85],[86],[87],[88]],[78,[84]],[79,[80],[81],[82],[83]]],[14,[29],[30,[65]],[31,[60,[61,[62],[63],[64]]]],[32,[58],[59]],[33,[47,[48,[49],[50],[51],[52],[53],[54],[55],[56],[57]]]],[34,[44],[45],[46]],[35,[36],[37],[38],[39],[40],[41],[42],[43]]],[15,[16],[17],[18,[19,[20,[27,[28]]],[21,[25,[26]]],[22,[23,[24]]]]]]]]]],"tag_map":[{"a":[["lang","en"]],"n":"html"},{"x":"\n    ","n":"head","l":"\n  "},{"a":[["class","calibre1 pcalibre1 pcalibre"]],"x":"\n","n":"body","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["id","_将_git_嵌入你的应用"],["title","将 Git 嵌入你的应用"],["type","chapter"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["id","G6PI2-78ecc950e459438e8d0462081a6fa7a8"]],"x":"\n","n":"header","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"假设你的应用程序的目标人群是开发者，如果它能够被整合进一些源码控制的功能，那真真是极好的。\n甚至对于一个例如文档编辑器之类的不是为开发者而设计的应用程序，它们也可能从版本控制系统中受益，并且 Git 的实现方式在很多情况下都表现得非常出色。","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"如果你想将 Git 整合进你的应用程序的话，一般来说你有三种可能的选择：启动一个 shell 来使用 Git 的命令行工具；使用 Libgit2；或者使用 JGit。","n":"p","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","命令行 Git 方式"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","Libgit2"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","JGit"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","calibre6 pcalibre1 pcalibre"],["id","_jgit"]],"x":"JGit","n":"h2","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"\n如果你想在一个 Java 程序中使用 Git ，有一个功能齐全的 Git 库，那就是 JGit 。\nJGit 是一个用 Java 写成的功能相对健全的 Git 的实现，它在 Java 社区中被广泛使用。\nJGit 项目由 Eclipse 维护，它的主页在 ","n":"p","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","起步"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","底层命令"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","高层命令"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","拓展阅读"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","pcalibre1 calibre7 pcalibre"],["id","_拓展阅读"]],"x":"拓展阅读","n":"h3","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"这只是 JGit 的全部能力的冰山一角。\n如果你对这有兴趣并且想深入学习，在下面可以找到一些信息和灵感。","n":"p","l":"\n"},{"a":[["class","content pcalibre1 pcalibre"]],"x":"\n","n":"div","l":"\n"},{"a":[["class","calibre10 pcalibre1 pcalibre"]],"x":"\n","n":"ul","l":"\n"},{"a":[["class","pcalibre7 calibre11 pcalibre1"]],"x":"\n","n":"li","l":"\n"},{"a":[["class","pcalibre7 calibre11 pcalibre1"]],"x":"\n","n":"li","l":"\n"},{"a":[["class","pcalibre7 calibre11 pcalibre1"]],"x":"\n","n":"li","l":"\n"},{"a":[["class","pcalibre1 pcalibre principal"]],"n":"span","l":"\n"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","http://stackoverflow.com/questions/6861881"],["target","_blank"],["rel","noopener noreferrer"]],"x":"http://stackoverflow.com/questions/6861881","n":"a","l":" 指出了几个好的资源。"},{"a":[["class","pcalibre1 pcalibre principal"]],"x":"JGit Cookbook ： ","n":"span","l":"\n"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","https://github.com/centic9/jgit-cookbook"],["target","_blank"],["rel","noopener noreferrer"]],"x":"https://github.com/centic9/jgit-cookbook","n":"a","l":" 拥有许多如何利用 JGit 实现特定任务的例子。"},{"a":[["class","pcalibre1 pcalibre principal"]],"x":"JGit API 在线官方文档： ","n":"span","l":"\n"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","http://download.eclipse.org/jgit/docs/latest/apidocs"],["target","_blank"],["rel","noopener noreferrer"]],"x":"http://download.eclipse.org/jgit/docs/latest/apidocs","n":"a","l":" 。\n这是基本的 Javadoc ，所以你也可以在你最喜欢的 JVM IDE 上将它们安装它们到本地。"},{"a":[["class","pcalibre1 calibre7 pcalibre"],["id","_高层命令"]],"x":"高层命令","n":"h3","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"底层 API 更加完善，但是有时将它们串起来以实现普通的目的非常困难，例如将一个文件添加到索引，或者创建一个新的提交。\n为了解决这个问题， JGit 提供了一系列高层 API ，使用这些 API 的入口点就是 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"Git 类有一系列非常好的 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"这是一个 Git 类的公共样式，这个方法返回一个可以让你串连若干方法调用来设置参数的命令对象，当你调用 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"在 Git 类中还可以使用许多其它的命令，包括但不限于 ","n":"p","l":"\n"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"add","n":"code","l":"、"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"blame","n":"code","l":"、"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"commit","n":"code","l":"、"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"clean","n":"code","l":"、"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"push","n":"code","l":"、"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"rebase","n":"code","l":"、"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"revert","n":"code","l":" 和 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"reset","n":"code","l":"。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".call()","n":"code","l":" 时它们就会被执行。\n在这情况下，我们只是请求了 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"origin","n":"code","l":" 远程的标签，而不是头部。\n还要注意用于验证的 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"CredentialsProvider","n":"code","l":" 对象的使用。"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span","l":"CredentialsProvider cp = "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"new","n":"span","l":" UsernamePasswordCredentialsProvider("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"username\"","n":"span","l":", "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"p4ssw0rd\"","n":"span","l":");\nCollection<Ref> remoteRefs = git.lsRemote()\n    .setCredentialsProvider(cp)\n    .setRemote("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"origin\"","n":"span","l":")\n    .setTags("},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"true","n":"span","l":")\n    .setHeads("},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"false","n":"span","l":")\n    .call();\n"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"for","n":"span","l":" (Ref ref : remoteRefs) {\n    System.out.println(ref.getName() + "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\" -> \"","n":"span","l":" + ref.getObjectId().name());\n}"},{"a":[["class","pcalibre1 pcalibre calibre4"]],"x":"构建器","n":"em","l":" 风格的高层方法，它可以用来构造一些复杂的行为。\n我们来看一个例子——做一件类似 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git ls-remote","n":"code","l":" 的事。"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span","l":"Repository repo;\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 构建仓库。。。","n":"span","l":"\nGit git = "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"new","n":"span","l":" Git(repo);"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"Git","n":"code","l":" 类："},{"a":[["class","pcalibre1 calibre7 pcalibre"],["id","_底层命令"]],"x":"底层命令","n":"h3","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"JGit 的 API 有两种基本的层次：底层命令和高层命令。\n这个两个术语都来自 Git ，并且 JGit 也被按照相同的方式粗略地划分：高层 API 是一个面向普通用户级别功能的友好的前端（一系列普通用户使用 Git 命令行工具时可能用到的东西），底层 API 则直接作用于低级的仓库对象。","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"大多数 JGit 会话会以 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"无论你的程序是否知道仓库的确切位置，builder 中的那个流畅的 API 都可以提供给它寻找仓库所需所有信息。\n它可以使用环境变量 （","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"当你拥有一个 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"这里完成了一大堆事情，所以我们还是一次理解一段的好。","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"第一行获取一个指向 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"第二行获得以 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"接下来两行展示了如何装载一个对象的原始内容。\n在这个例子中，我们调用 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"接下来几行展现了如何创建一个新的分支。\n我们创建一个 RefUpdate 实例，配置一些参数，然后调用 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"最后一个例子展示了如何从 Git 配置文件中获取 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"这只是底层 API 的冰山一角，另外还有许多可以使用的方法和类。\n还有一个没有放在这里说明的，就是 JGit 是用异常机制来处理错误的。\nJGit API 有时使用标准的 Java 异常（例如 ","n":"p","l":"\n"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"IOException","n":"code","l":" ），但是它也提供了大量 JGit 自己定义的异常类型（例如 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"NoRemoteRepositoryException","n":"code","l":"、 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"CorruptObjectException","n":"code","l":" 和 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"NoMergeBaseException","n":"code","l":"）。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"user.name","n":"code","l":" 的值。\n这个 Config 实例使用我们先前打开的仓库做本地配置，但是它也会自动地检测并读取全局和系统的配置文件。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".update()","n":"code","l":" 来确认这个更改。\n删除相同分支的代码就在这行下面。\n记住必须先 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".setForceUpdate(true)","n":"code","l":" 才能让它工作，否则调用 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".delete()","n":"code","l":" 只会返回 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"REJECTED","n":"code","l":" ，然后什么都没有发生。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"ObjectLoader.copyTo()","n":"code","l":" 直接向标准输出流输出对象的内容，除此之外 ObjectLoader 还带有读取对象的类型和长度并将它以字节数组返回的方法。\n对于一个（ "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".isLarge()","n":"code","l":" 返回 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"true","n":"code","l":" 的）大的对象，你可以调用 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".openStream()","n":"code","l":" 来获得一个类似 InputStream 的对象，它可以在没有一次性将所有数据拉到内存的前提下读取对象的原始数据。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"master","n":"code","l":" 引用的目标，它返回一个 ObjectId 实例。\n不管是否存在于一个 Git 对象的数据库，ObjectId 都会代表一个对象的 SHA-1 哈希。\n第三行与此相似，但是它展示了 JGit 如何处理 rev-parse 语法（要了解更多，请看 "},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","javascript:void(0)"],["data-ezPJKgrMLI5iYpd7vlZT7E","{\"frag\": \"r_branch_references\", \"name\": \"text/part0012.html\"}"]],"x":"分支引用","n":"a","l":" ），你可以传入任何 Git 了解的对象说明符，然后 JGit 会返回该对象的一个有效的 ObjectId ，或者 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"null","n":"code","l":" 。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"master","n":"code","l":" 引用的指针。\nJGit 自动抓取位于 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"refs/heads/master","n":"code","l":" 的 "},{"a":[["class","pcalibre1 pcalibre calibre4"]],"x":"真正的","n":"em","l":" master 引用，并返回一个允许你获取该引用的信息的对象。\n你可以获取它的名字 （"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".getName()","n":"code","l":"） ，或者一个直接引用的目标对象 （"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".getObjectId()","n":"code","l":"） ，或者一个指向该引用的符号指针 （"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".getTarget()","n":"code","l":"） 。\n引用对象也经常被用来表示标签的引用和对象，所以你可以询问某个标签是否被 “削除” 了，或者说它指向一个标签对象的（也许很长的）字符串的最终目标。"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 获取引用","n":"span","l":"\nRef master = repo.getRef("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"master\"","n":"span","l":");\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 获取该引用所指向的对象","n":"span","l":"\nObjectId masterTip = master.getObjectId();\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// Rev-parse","n":"span","l":"\nObjectId obj = repo.resolve("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"HEAD^{tree}\"","n":"span","l":");\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 装载对象原始内容","n":"span","l":"\nObjectLoader loader = repo.open(masterTip);\nloader.copyTo(System.out);\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 创建分支","n":"span","l":"\nRefUpdate createBranch1 = repo.updateRef("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"refs/heads/branch1\"","n":"span","l":");\ncreateBranch1.setNewObjectId(masterTip);\ncreateBranch1.update();\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 删除分支","n":"span","l":"\nRefUpdate deleteBranch1 = repo.updateRef("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"refs/heads/branch1\"","n":"span","l":");\ndeleteBranch1.setForceUpdate("},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"true","n":"span","l":");\ndeleteBranch1.delete();\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 配置","n":"span","l":"\nConfig cfg = repo.getConfig();\nString name = cfg.getString("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"user\"","n":"span","l":", "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"null","n":"span","l":", "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"name\"","n":"span","l":");"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"Repository","n":"code","l":" 实例后，你就能对它做各种各样的事。\n下面是一个速览："},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".readEnvironment()","n":"code","l":"） ，从工作目录的某处开始并搜索 （"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".setWorkTree(…).findGitDir()","n":"code","l":"） , 或者仅仅只是像上面那样打开一个已知的 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".git","n":"code","l":" 目录。"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 创建一个新仓库","n":"span","l":"\nRepository newlyCreatedRepo = FileRepositoryBuilder.create(\n    "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"new","n":"span","l":" File("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"/tmp/new_repo/.git\"","n":"span","l":"));\nnewlyCreatedRepo.create();\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 打开一个存在的仓库","n":"span","l":"\nRepository existingRepo = "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"new","n":"span","l":" FileRepositoryBuilder()\n    .setGitDir("},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"new","n":"span","l":" File("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"my_repo/.git\"","n":"span","l":"))\n    .build();"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"Repository","n":"code","l":" 类作为起点，你首先要做的事就是创建一个它的实例。\n对于一个基于文件系统的仓库来说（嗯， JGit 允许其它的存储模型），用 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"FileRepositoryBuilder","n":"code","l":" 完成它。"},{"a":[["class","pcalibre1 calibre7 pcalibre"],["id","_起步"]],"x":"起步","n":"h3","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"有很多种方式可以让 JGit 连接你的项目，并依靠它去写代码。\n最简单的方式也许就是使用 Maven 。你可以通过在你的 pom.xml 文件里的 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"在你读到这段文字时 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"如果你想自己管理二进制的依赖包，那么你可以从 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span","l":"javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java\njava -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","http://www.eclipse.org/jgit/download"],["target","_blank"],["rel","noopener noreferrer"]],"x":"http://www.eclipse.org/jgit/download","n":"a","l":" 获得预构建的 JGit 二进制文件。\n你可以像下面这样执行一个命令来将它们构建进你的项目。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"version","n":"code","l":" 很可能已经更新了，所以请浏览 "},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit"],["target","_blank"],["rel","noopener noreferrer"]],"x":"http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit","n":"a","l":" 以获取最新的仓库信息。\n当这一步完成之后， Maven 就会自动获取并使用你所需要的 JGit 库。"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"<dependency>","n":"span","l":"\n    "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"<groupId>","n":"span","l":"org.eclipse.jgit"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"</groupId>","n":"span","l":"\n    "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"<artifactId>","n":"span","l":"org.eclipse.jgit"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"</artifactId>","n":"span","l":"\n    "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"<version>","n":"span","l":"3.5.0.201409260305-r"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"</version>","n":"span","l":"\n"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"</dependency>","n":"span"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"<dependencies>","n":"code","l":" 标签中增加像下面这样的片段来完成这个整合。"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","http://www.eclipse.org/jgit"],["target","_blank"],["rel","noopener noreferrer"]],"x":"http://www.eclipse.org/jgit","n":"a","l":" 。"},{"a":[["class","calibre6 pcalibre1 pcalibre"],["id","_libgit2"]],"x":"Libgit2","n":"h2","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"©\n另外一种可以供你使用的是 Libgit2。\nLibgit2 是一个 Git 的非依赖性的工具，它致力于为其他程序使用 Git 提供更好的 API。\n你可以在 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"首先，让我们来看一下 C API 长啥样。\n这是一个旋风式旅行。","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"前两行打开一个 Git 版本库。\n这个 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"第二段代码使用了一种 rev-parse 语法（要了解更多，请看 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"下一段展示了如何访问一个提交的详情。\n最后一行使用了 ","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"从这个例子中，我们可以看到一些模式：","n":"p","l":"\n"},{"a":[["class","content pcalibre1 pcalibre"]],"x":"\n","n":"div","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"\n最后一点意味着你应该不会在使用 Libgit2 时编写 C 语言程序。\n但幸运的是，有许多可用的各种语言的绑定，能让你在特定的语言和环境中更加容易的操作 Git 版本库。\n我们来看一下下面这个用 Libgit2 的 Ruby 绑定写成的例子，它叫 Rugged，你可以在 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"你可以发现，代码看起来更加清晰了。\n首先， Rugged 使用异常机制，它可以抛出类似于 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","content pcalibre1 pcalibre"]],"x":"\n","n":"div","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"Ruby 的代码很好很简洁，另一方面因为 Libgit2 做了大量工作，所以代码运行起来其实速度也不赖。\n如果你不是一个 Ruby 程序员，我们在 ","n":"p","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","高级功能"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","其它绑定"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","扩展阅读"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","pcalibre1 calibre7 pcalibre"],["id","_扩展阅读"]],"x":"扩展阅读","n":"h3","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"当然，完全阐述 Libgit2 的能力已超出本书范围。\n如果你想了解更多关于 Libgit2 的信息，可以浏览它的 API 文档： ","n":"p","l":"\n"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","https://libgit2.github.com/libgit2"],["target","_blank"],["rel","noopener noreferrer"]],"x":"https://libgit2.github.com/libgit2","n":"a","l":", 以及一系列的指南： "},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","https://libgit2.github.com/docs"],["target","_blank"],["rel","noopener noreferrer"]],"x":"https://libgit2.github.com/docs","n":"a","l":".\n对于其它的绑定，检查附带的 README 和测试文件，那里通常有简易教程，以及指向拓展阅读的链接。"},{"a":[["class","pcalibre1 calibre7 pcalibre"],["id","r_libgit2_bindings"]],"x":"其它绑定","n":"h3","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"Libgit2 有很多种语言的绑定。\n在这篇文章中，我们展现了一个使用了几个更加完整的绑定包的小例子，这些库存在于许多种语言中，包括 C++、Go、Node.js、Erlang 以及 JVM ，它们的成熟度各不相同。\n官方的绑定集合可以通过浏览这个版本库得到：https://github.com/libgit2[] 。\n我们写的代码将返回当前 HEAD 指向的提交的提交信息(就像 ","n":"p","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","LibGit2Sharp"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","objective-git"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","chapter pcalibre1 pcalibre"],["title","pygit2"]],"x":"\n","n":"section","l":"\n"},{"a":[["class","calibre29 pcalibre1 pcalibre"],["id","_pygit2"]],"x":"pygit2","n":"h4","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"\nPython 的 Libgit2 绑定叫做 Pygit2 ，你可以在 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span","l":"pygit2.Repository("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"/path/to/repo\"","n":"span","l":") "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"# 打开版本库","n":"span","l":"\n    .head                          "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"# get the current branch","n":"span","l":"\n    .peel(pygit2.Commit)           "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"# walk down to the commit","n":"span","l":"\n    .message                       "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"# read the message","n":"span"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","http://www.pygit2.org/"],["target","_blank"],["rel","noopener noreferrer"]],"x":"http://www.pygit2.org/","n":"a","l":" 找到它。\n我们的示例程序："},{"a":[["class","calibre29 pcalibre1 pcalibre"],["id","_objective_git"]],"x":"objective-git","n":"h4","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"\n如果你的应用运行在一个 Apple 平台上，你很有可能使用 Objective-C 作为实现语言。\nObjective-Git (","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"Objective-git 与 Swift 完美兼容，所以你把 Objective-C 落在一边的时候不用恐惧。","n":"p","l":"\n"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span","l":"GTRepository *repo =\n    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"@\"/path/to/repo\"","n":"span","l":"] error:NULL];\nNSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","https://github.com/libgit2/objective-git"],["target","_blank"],["rel","noopener noreferrer"]],"x":"https://github.com/libgit2/objective-git","n":"a","l":") 是这个环境下的 Libgit2 绑定。\n一个例子看起来类似这样："},{"a":[["class","calibre29 pcalibre1 pcalibre"],["id","_libgit2sharp"]],"x":"LibGit2Sharp","n":"h4","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"\n如果你在编写一个 .NET 或者 Mono 应用，那么 LibGit2Sharp (","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"对于 Windows 桌面应用，一个叫做 NuGet 的包会让你快速上手。","n":"p","l":"\n"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"new","n":"span","l":" Repository("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"@\"C:\\path\\to\\repo\"","n":"span","l":").Head.Tip.Message;"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","https://github.com/libgit2/libgit2sharp"],["target","_blank"],["rel","noopener noreferrer"]],"x":"https://github.com/libgit2/libgit2sharp","n":"a","l":") 就是你所需要的。\n这个绑定是用 C# 写成的，并且已经采取许多措施来用令人感到自然的 CLR API 包装原始的 Libgit2 的调用。\n我们的例子看起来就像这样："},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git log -1","n":"code","l":" 那样)。"},{"a":[["class","pcalibre1 calibre7 pcalibre"],["id","_高级功能"]],"x":"高级功能","n":"h3","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"Libgit2 有几个超过核心 Git 的能力。\n例如它的可定制性：Libgit2 允许你为一些不同类型的操作自定义的`‘后端’'，让你得以使用与原生 Git 不同的方式存储东西。\nLibgit2 允许为自定义后端指定配置、引用的存储以及对象数据库，","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"我们来看一下它究竟是怎么工作的。\n下面的例子借用自 Libgit2 团队提供的后端样本集 （可以在 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"n":"p","l":"\n"},{"a":[["class","content pcalibre1 pcalibre"]],"x":"\n","n":"div","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"但是 ","n":"p","l":"\n"},{"a":[["class","listing pcalibre1 pcalibre"]],"x":"\n","n":"figure","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"这个初始化函数为该结构分配内存，设置自定义的上下文，然后填写它支持的 ","n":"p","l":"\n"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"parent","n":"code","l":" 结构的成员。\n阅读 Libgit2 的 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"include/git2/sys/odb_backend.h","n":"code","l":" 源码以了解全部调用签名，你特定的使用环境会帮你决定使用哪一种调用签名。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"my_backend_struct","n":"code","l":" 的第一个成员必须是一个 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_odb_backend","n":"code","l":" 结构，这是一个微妙的限制：这样就能确保内存布局是 Libgit2 的代码所期望的样子。\n其余都是随意的，这个结构的大小可以随心所欲。"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"typedef","n":"span","l":" "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"struct","n":"span","l":" {\n    git_odb_backend parent;\n\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 其它的一些东西","n":"span","l":"\n    "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"void","n":"span","l":" *custom_context;\n} my_backend_struct;\n\n"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"int","n":"span","l":" git_odb_backend_mine(git_odb_backend **backend_out, "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"/*…*/","n":"span","l":")\n{\n    my_backend_struct *backend;\n\n    backend = calloc(1, "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"sizeof","n":"span","l":" (my_backend_struct));\n\n    backend->custom_context = "},{"a":[["class","pcalibre1 calibre28 pcalibre"]],"x":"…","n":"span","l":";\n\n    backend->parent.read = &my_backend__read;\n    backend->parent.read_prefix = &my_backend__read_prefix;\n    backend->parent.read_header = &my_backend__read_header;\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// ……","n":"span","l":"\n\n    *backend_out = (git_odb_backend *) backend;\n\n    "},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"return","n":"span","l":" GIT_SUCCESS;\n}"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_odb_backend_mine","n":"code","l":" 是个什么东西呢？\n嗯，那是一个你自己的 ODB 实现的构造器，并且你能在那里做任何你想做的事，前提是你能正确地填写 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_odb_backend","n":"code","l":" 结构。\n它看起来_应该_是这样的："},{"a":[["class","calibre30 pcalibre1 pcalibre"]],"x":"\n","n":"ol","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","4"]],"x":"④","n":"i","l":" 打开一个版本库，并让它使用我们的 ODB 来寻找对象。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","3"]],"x":"③","n":"i","l":" 为这个前端增加一个后端。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","2"]],"x":"②","n":"i","l":" 初始化一个自定义 ODB 后端。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","1"]],"x":"①","n":"i","l":" 初始化一个空的对象数据库（ ODB ） “前端”，它将被作为一个用来做真正的工作的 “后端” 的容器。"},{"a":[["class","pcalibre1 pcalibre calibre4"]],"x":"(注意：这个错误被捕获了，但是没有被处理。我们希望你的代码比我们的更好。)","n":"em"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span","l":"git_odb *odb;\n"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"int","n":"span","l":" error = git_odb_new(&odb); "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","1"]],"x":"①","n":"i","l":"\n\ngit_odb_backend *my_backend;\nerror = git_odb_backend_mine(&my_backend, "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"/*…*/","n":"span","l":"); "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","2"]],"x":"②","n":"i","l":"\n\nerror = git_odb_add_backend(odb, my_backend, 1); "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","3"]],"x":"③","n":"i","l":"\n\ngit_repository *repo;\nerror = git_repository_open(&repo, "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"some-path\"","n":"span","l":");\nerror = git_repository_set_odb(odb); "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","4"]],"x":"④","n":"i"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","https://github.com/libgit2/libgit2-backends"],["target","_blank"],["rel","noopener noreferrer"]],"x":"https://github.com/libgit2/libgit2-backends","n":"a","l":" 上找到）。\n一个对象数据库的自定义后端是这样建立的："},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","javascript:void(0)"],["id","xref-r_libgit2_bindings"],["data-ezPJKgrMLI5iYpd7vlZT7E","{\"frag\": \"r_libgit2_bindings\", \"name\": \"text/part0017.html\"}"]],"x":"其它绑定","n":"a","l":" 有提到其它的一些绑定。"},{"a":[["class","calibre30 pcalibre1 pcalibre"]],"x":"\n","n":"ol","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","calibre31 pcalibre1 pcalibre"]],"n":"li","l":"\n"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","8"]],"x":"⑧","n":"i","l":" 返回值是一个新提交对象的 SHA-1 哈希，你可以用它来获得一个 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"Commit","n":"code","l":" 对象。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","7"]],"x":"⑦","n":"i","l":" 在做一个提交的过程中， Rugged （和 Libgit2 ）能在需要时更新引用。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","6"]],"x":"⑥","n":"i","l":" 当创建一个提交时，你必须指定这个新提交的父提交。\n这里使用了 HEAD 的末尾作为单一的父提交。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","5"]],"x":"⑤","n":"i","l":" 提交的信息。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","4"]],"x":"④","n":"i","l":" 我们在 author 栏和 committer 栏使用相同的签名。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","3"]],"x":"③","n":"i","l":" 这就在 ODB 中创建了一个新的树，并在一个新的提交中使用它。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","2"]],"x":"②","n":"i","l":" 将 HEAD 提交树填入索引，并在路径 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"newfile.txt","n":"code","l":" 增加新文件。"},{"a":[["class","conum1 pcalibre1 pcalibre"],["data-value","1"]],"x":"①","n":"i","l":" 创建一个新的 blob ，它包含了一个新文件的内容。"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span","l":"blob_id = repo.write("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"Blob contents\"","n":"span","l":", "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":blob","n":"span","l":") "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","1"]],"x":"①","n":"i","l":"\n\nindex = repo.index\nindex.read_tree(repo.head.target.tree)\nindex.add("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":path","n":"span","l":" => "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"'newfile.txt'","n":"span","l":", "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":oid","n":"span","l":" => blob_id) "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","2"]],"x":"②","n":"i","l":"\n\nsig = {\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":email","n":"span","l":" => "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"bob@example.com\"","n":"span","l":",\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":name","n":"span","l":" => "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"Bob User\"","n":"span","l":",\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":time","n":"span","l":" => Time.now,\n}\n\ncommit_id = Rugged::Commit.create(repo,\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":tree","n":"span","l":" => index.write_tree(repo), "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","3"]],"x":"③","n":"i","l":"\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":author","n":"span","l":" => sig,\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":committer","n":"span","l":" => sig, "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","4"]],"x":"④","n":"i","l":"\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":message","n":"span","l":" => "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"Add newfile.txt\"","n":"span","l":", "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","5"]],"x":"⑤","n":"i","l":"\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":parents","n":"span","l":" => repo.empty? ? [] : [ repo.head.target ].compact, "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","6"]],"x":"⑥","n":"i","l":"\n    "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":update_ref","n":"span","l":" => "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"'HEAD'","n":"span","l":", "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","7"]],"x":"⑦","n":"i","l":"\n)\ncommit = repo.lookup(commit_id) "},{"a":[["class","conum pcalibre1 pcalibre"],["data-value","8"]],"x":"⑧","n":"i"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"ConfigError","n":"code","l":" 或者 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"ObjectError","n":"code","l":" 之类的东西来告知错误的情况。\n其次，不需要明确资源释放，因为 Ruby 是支持垃圾回收的。\n我们来看一个稍微复杂一点的例子：从头开始制作一个提交。"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span","l":"repo = Rugged::Repository.new("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"'path/to/repository'","n":"span","l":")\ncommit = repo.head.target\nputs commit.message\nputs "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"","n":"span"},{"a":[["class","pcalibre1 pcalibre calibre16"]],"x":"#{","n":"span","l":"commit.author["},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":name","n":"span","l":"]"},{"a":[["class","pcalibre1 pcalibre calibre16"]],"x":"}","n":"span"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":" <","n":"span"},{"a":[["class","pcalibre1 pcalibre calibre16"]],"x":"#{","n":"span","l":"commit.author["},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":":email","n":"span","l":"]"},{"a":[["class","pcalibre1 pcalibre calibre16"]],"x":"}","n":"span"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":">\"","n":"span","l":"\ntree = commit.tree"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","https://github.com/libgit2/rugged"],["target","_blank"],["rel","noopener noreferrer"]],"x":"https://github.com/libgit2/rugged","n":"a","l":" 找到它。"},{"a":[["class","calibre10 pcalibre1 pcalibre"]],"x":"\n","n":"ul","l":"\n"},{"a":[["class","pcalibre7 calibre11 pcalibre1"]],"x":"\n","n":"li","l":"\n"},{"a":[["class","pcalibre7 calibre11 pcalibre1"]],"x":"\n","n":"li","l":"\n"},{"a":[["class","pcalibre7 calibre11 pcalibre1"]],"x":"\n","n":"li","l":"\n"},{"a":[["class","pcalibre7 calibre11 pcalibre1"]],"x":"\n","n":"li","l":"\n"},{"a":[["class","pcalibre1 pcalibre principal"]],"x":"用 C 来写有点蛋疼。","n":"span","l":"\n"},{"a":[["class","pcalibre1 pcalibre principal"]],"x":"如果 Libgit2 在一个调用中返回一个 ","n":"span","l":"\n"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"const","n":"code","l":" 指针，你不需要释放它，但是当它所指向的对象被释放时它将不可用。"},{"a":[["class","pcalibre1 pcalibre principal"]],"x":"如果 Libgit2 为你填入一个指针，那么你有责任释放它。","n":"span","l":"\n"},{"a":[["class","pcalibre1 pcalibre principal"]],"x":"如果你声明了一个指针，并在一个 Libgit2 调用中传递一个引用，那么这个调用可能返回一个 int 类型的错误码。\n值 ","n":"span","l":"\n"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"0","n":"code","l":" 表示成功，比它小的则是一个错误。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_oid","n":"code","l":" 类型，这是 Libgit2 用来表示一个 SHA-1 哈希的方法。"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","javascript:void(0)"],["id","xref--ch07-git-tools--r_branch_references"],["data-ezPJKgrMLI5iYpd7vlZT7E","{\"frag\": \"r_branch_references\", \"name\": \"text/part0012.html\"}"]],"x":"分支引用","n":"a","l":" ）来得到 HEAD 真正指向的提交。\n返回类型是一个 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_object","n":"code","l":" 指针，它指代位于版本库里的 Git 对象数据库中的某个东西。\n"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_object","n":"code","l":" 实际上是几种不同的对象的 “父” 类型，每个 “子” 类型的内存布局和 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_object","n":"code","l":" 是一样的，所以你能安全地把它们转换为正确的类型。\n在上面的例子中， "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_object_type(commit)","n":"code","l":" 会返回 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"GIT_OBJ_COMMIT","n":"code","l":" ，所以转换成 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_commit","n":"code","l":" 指针是安全的。"},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_repository","n":"code","l":" 类型代表了一个在内存中带有缓存的指向一个版本库的句柄。\n这是最简单的方法，只是你必须知道一个版本库的工作目录或者一个 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":".git","n":"code","l":" 文件夹的精确路径。\n另外还有 "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_repository_open_ext","n":"code","l":" ，它包括了带选项的搜索， "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_clone","n":"code","l":" 及其同类可以用来做远程版本库的本地克隆， "},{"a":[["class","pcalibre1 pcalibre literal"]],"x":"git_repository_init","n":"code","l":" 则可以创建一个全新的版本库。"},{"a":[["class","source pcalibre1 pcalibre"]],"n":"pre","l":"\n"},{"a":[["class","calibre13 pcalibre1 pcalibre"]],"n":"code"},{"a":[["class","calibre14 pcalibre1 pcalibre"]],"n":"span"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 打开一个版本库","n":"span","l":"\ngit_repository *repo;\n"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"int","n":"span","l":" error = git_repository_open(&repo, "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"/path/to/repository\"","n":"span","l":");\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 逆向引用 HEAD 到一个提交","n":"span","l":"\ngit_object *head_commit;\nerror = git_revparse_single(&head_commit, repo, "},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"HEAD^{commit}\"","n":"span","l":");\ngit_commit *commit = (git_commit*)head_commit;\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 显示这个提交的一些详情","n":"span","l":"\nprintf("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"%s\"","n":"span","l":", git_commit_message(commit));\n"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"const","n":"span","l":" git_signature *author = git_commit_author(commit);\nprintf("},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"%s <%s>","n":"span"},{"a":[["class","pcalibre1 pcalibre calibre16"]],"x":"\\n","n":"span"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"\"","n":"span","l":", author->name, author->email);\n"},{"a":[["class","pcalibre1 calibre15 pcalibre"]],"x":"const","n":"span","l":" git_oid *tree_id = git_commit_tree_id(commit);\n\n"},{"a":[["class","pcalibre1 pcalibre calibre17"]],"x":"// 清理现场","n":"span","l":"\ngit_commit_free(commit);\ngit_repository_free(repo);"},{"a":[["class","link pcalibre5 pcalibre4 pcalibre3 pcalibre2 pcalibre1 pcalibre"],["href","http://libgit2.github.com"],["target","_blank"],["rel","noopener noreferrer"]],"x":"http://libgit2.github.com","n":"a","l":" 找到它。"},{"a":[["class","calibre6 pcalibre1 pcalibre"],["id","_命令行_git_方式"]],"x":"命令行 Git 方式","n":"h2","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"一种方式就是启动一个 shell 进程并在里面使用 Git 的命令行工具来完成任务。\n这种方式看起来很循规蹈矩，但是它的优点也因此而来，就是支持所有的 Git 的特性。\n它也碰巧相当简单，因为几乎所有运行时环境都有一个相对简单的方式来调用一个带有命令行参数的进程。\n然而，这种方式也有一些固有的缺点。","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"一个就是所有的输出都是纯文本格式。\n这意味着你将被迫解析 Git 的有时会改变的输出格式，以随时了解它工作的进度和结果。更糟糕的是，这可能是无效率并且容易出错的。","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"另外一个就是令人捉急的错误修复能力。\n如果一个版本库被莫名其妙地损毁，或者用户使用了一个奇奇怪怪的配置， Git 只会简单地拒绝表现自己的强大能力。","n":"p","l":"\n"},{"a":[["class","calibre3 pcalibre1 pcalibre"]],"x":"还有一个就是进程的管理。\nGit 会要求你在一个独立的进程中维护一个 shell 环境，这可能会无谓地增加复杂性。\n试图协调许许多多的类似的进程（尤其是在某些情况下，当不同的进程在访问相同的版本库时）是对你的能力的极大挑战。","n":"p","l":"\n"},{"a":[["class","pcalibre1 chapter-header pcalibre"]],"x":"\n","n":"div","l":"\n"},{"a":[["class","chapter-title pcalibre1 pcalibre"]],"n":"h1","l":"\n"},{"a":[["class","subtitle pcalibre1 pcalibre"]],"n":"small"},{"a":[["class","calibre2 pcalibre1 pcalibre"]],"x":"将","n":"b","l":" "},{"a":[["class","calibre2 pcalibre1 pcalibre"]],"x":"Git","n":"b","l":" "},{"a":[["class","calibre2 pcalibre1 pcalibre"]],"x":"嵌入你的应用","n":"b"},{"x":"将 Git 嵌入你的应用","n":"title","l":"\n    "},{"a":[["type","text/javascript"]],"x":"\ndocument.addEventListener('DOMContentLoaded', function(event, reader) {\n  if (!(reader = navigator.epubReadingSystem)) {\n    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };\n    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;\n  }\n  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));\n});\n","n":"script","l":"\n    \n  "},{"a":[["href","ezPJKgrMLI5iYpd7vlZT7E|c3R5bGVzLzAwMDMuY3Nz|"],["rel","stylesheet"],["type","text/css"]],"n":"link","l":"\n"},{"a":[["href","ezPJKgrMLI5iYpd7vlZT7E|c3R5bGVzLzAwMDIuY3Nz|"],["rel","stylesheet"],["type","text/css"]],"n":"link","l":"\n"}]}